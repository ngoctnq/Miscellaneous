#!/usr/bin/env pythonfrom copy import deepcopy# params: rows/columns, count, head/tailconstraint = [[['','D'],['B',''],['',''],['','C'],['','']],[['',''],['C','D'],['','D'],['','C'],['','']]]choices = 'ABCD'# constraint = [[['A',''],['',''],['','']],[['',''],['',''],['A','']]]# choices = 'AB'# start reinitializingchoices += 'X'dim = len(constraint[0])maxX = dim-len(choices)+1def reset_board(board):    for i in range(dim):        for j in range(dim):            board[i][j] = ''def min_coord(board):    curr = None    currMin = 10 # arbitrary large number    for i in range(dim):        for j in range(dim):            currLen = len(board[i][j])            if currLen == 2:                return [i,j]            if currLen < currMin and currLen > 1:                currMin = currLen                curr = [i,j]    return currdef is_deadend(board):    for i in range(dim):        for j in range(dim):            if len(board[i][j]) > 1:                return False    return Truedef has_no_null(board):    for i in range(dim):        for j in range(dim):            if len(board[i][j]) == 0:                return False    return Truedef is_legit(board):    # check rows    for i in range(dim):        temp = ''        for j in range(dim):            temp += board[i][j]        for j in choices[:-1]:            if j not in temp:                return False    # check columns    for i in range(dim):        temp = ''        for j in range(dim):            temp += board[j][i]        for j in choices[:-1]:            if j not in temp:                return False       return Truedef init_board():    # yo fuck Python and its initialization man    board = []    for i in range(dim):        board.append([])        for j in range(dim):            board[i].append(choices)    # optimize    for i in range(dim):        # head // j = 0        for j in range(dim-len(choices)+2, dim):            board[i][j] = board[i][j].replace(constraint[0][i][0],'')            board[j][i] = board[j][i].replace(constraint[1][i][0],'')        # toe // j = 1        for j in range(0, len(choices)-2):            board[i][j] = board[i][j].replace(constraint[0][i][1],'')            board[j][i] = board[j][i].replace(constraint[1][i][1],'')                # check only case    cancel_all(board)    return boarddef cancel_all(board):    changed = True    while changed:        changed = False        for c in choices:            if c != 'X':                # check rows                for i in range(dim):                    count = 0                    lastAppeared = -1                    for j in range(dim):                        if c in board[i][j]:                            if c == board[i][j]:                                count = -1                                break                            count += 1                            lastAppeared = j                    if count == 1:                        changed = True                        board[i][lastAppeared] = c                        optimize(board,[i,lastAppeared])                    if count == 0:                        reset_board(board)                        break                        # raise ValueError('No solutions available! Row '\                        #     + str(i) + ', char ' + str(c))                # check columns                for i in range(dim):                    count = 0                    lastAppeared = -1                    for j in range(dim):                        if c in board[j][i]:                            if c == board[j][i]:                                count = -1                                return                            count += 1                            lastAppeared = j                    if count == 1:                        changed = True                        board[lastAppeared][i] = c                        optimize(board,[lastAppeared,i])                    if count == 0:                        reset_board(board)                        return                        # raise ValueError('No solutions available! Column '\                        #     + str(i) + ', char ' + str(c))            else:                # check rows                for i in range(dim):                    xcount = 0                    for j in range(dim):                        if board[i][j] == c:                            xcount += 1                    if xcount == maxX:                        for j in range(dim):                            if board[i][j] != c:                                board[i][j] = board[i][j].replace(c,'')                # check columns                for i in range(dim):                    xcount = 0                    for j in range(dim):                        if board[j][i] == c:                            xcount += 1                    if xcount == maxX:                        for j in range(dim):                            if board[j][i] != c:                                board[j][i] = board[i][j].replace(c,'')def optimize(board, coord):    # check top    if board[coord[0]][coord[1]] != '':        # check rows        if board[coord[0]][coord[1]] == constraint[0][coord[0]][0]:            for j in range(coord[1]):                board[coord[0]][j] = 'X'        if board[coord[0]][coord[1]] == constraint[0][coord[0]][1]:            for j in range(coord[1]+1,dim):                board[coord[0]][j] = 'X'        # check columns        if board[coord[0]][coord[1]] == constraint[1][coord[1]][0]:            for i in range(coord[0]):                board[i][coord[1]] = 'X'        if board[coord[0]][coord[1]] == constraint[1][coord[1]][1]:            for i in range(coord[0]+1,dim):                board[i][coord[1]] = 'X'    # clear all    if len(board[coord[0]][coord[1]]) != 1:        raise ValueError('Not supposed to reduce a nonsingular string!')    if board[coord[0]][coord[1]] != 'X':        for i in range(dim):            if i != coord[0]:                board[i][coord[1]] = board[i][coord[1]].replace(board[coord[0]][coord[1]],'')        for j in range(dim):            if j != coord[1]:                board[coord[0]][j] = board[coord[0]][j].replace(board[coord[0]][coord[1]],'')    # TODO: unoptimized as cancel all board rather than    # just one character and its corresponding columns and rows    cancel_all(board)def printOut(board):    for i in range(dim):        for j in range(dim):            if board[i][j] == 'X':                print '.',            else:                print board[i][j],        printdef mass_optimize(board):    for i in range(dim):        for j in range(dim):            if len(board[i][j]) == 1 and board[i][j] != 'X':                optimize(board,[i,j])def solve(shit_to_solve):    # print len(shit_to_solve)    board = shit_to_solve.pop()    # print board    if is_legit(board):        if is_deadend(board):            print "SOLUTION FOUND!"            printOut(board)            print        else:            if has_no_null(board):                minc = min_coord(board)                if minc == None:                    return                # print                # print minc                # print 'org', board                new_board = deepcopy(board)                new_board[minc[0]][minc[1]] = new_board[minc[0]][minc[1]][0]                board[minc[0]][minc[1]] = board[minc[0]][minc[1]][1:]                cancel_all(board)                cancel_all(new_board)                mass_optimize(board)                mass_optimize(new_board)                # print 'new', new_board                # print 'old', board                # print                shit_to_solve.append(board)                shit_to_solve.append(new_board)def main():    shit_to_solve = [init_board()]    while len(shit_to_solve) != 0:    # for i in range(4):        solve(shit_to_solve)main()